import React, { useRef, useEffect, useState } from 'react';
import Highcharts from 'highcharts/highstock';
import HighchartsReact from 'highcharts-react-official';
import { useDelaySparkline, useRealtimePrices } from '../../hooks/useRealtimePrices';

// Load Highcharts modules
import 'highcharts/modules/price-indicator';
import 'highcharts/modules/exporting';
import 'highcharts/modules/accessibility';

const MiniPriceChartItem = ({ assetIdentifier }) => {
  const chartRef = useRef(null);
  const containerRef = useRef(null);
  const [chartData, setChartData] = useState([]);
  const [isInitialized, setIsInitialized] = useState(false);
  const [basePrice, setBasePrice] = useState(null); // Í∏∞Ï§Ä Í∞ÄÍ≤© Ï†ÄÏû•
  const [initialPrice, setInitialPrice] = useState(null); // Ï¥àÍ∏∞ Í∞ÄÍ≤© Ï†ÄÏû• (ÏÉÅÎåÄÏ†Å Î≥ÄÌôîÏú® Í≥ÑÏÇ∞Ïö©)
  const [yAxisRange, setYAxisRange] = useState({ min: null, max: null }); // YÏ∂ï Î≤îÏúÑ Í≥†Ï†ï
  const [xAxisRange, setXAxisRange] = useState({ min: null, max: null }); // XÏ∂ï Î≤îÏúÑ Í≥†Ï†ï
  const [lastPointDirection, setLastPointDirection] = useState(null); // 'up' | 'down' | 'flat'
  // ÌôîÎ©¥ ÌÅ¨Í∏∞ ÏÉÅÌÉú Ï†úÍ±∞ - Î™®Îì† ÌôîÎ©¥ÏóêÏÑú ÎèôÏùºÌïú ÏÑ§Ï†ï ÏÇ¨Ïö©
  
  // ÎßàÏßÄÎßâ Í∞ÄÍ≤© Ìè¨Ïù∏ÌÑ∞Ïóê "ÎπõÎÇòÎäî" Ìö®Í≥ºÎ•º Ï£ºÍ∏∞ ÏúÑÌïú CSS
  const glowingMarkerStyle = `
    @keyframes glowing {
      0% { filter: drop-shadow(0 0 3px #00d4ff); }
      50% { filter: drop-shadow(0 0 10px #00d4ff) drop-shadow(0 0 10px #00d4ff); }
      100% { filter: drop-shadow(0 0 3px #00d4ff); }
    }
    .highcharts-last-point-marker .highcharts-point {
      animation: glowing 1.5s infinite;
      transition: transform 0.5s ease-out;
    }
  `;
  
  // Fallback data for testing
  const fallbackData = [
    [Date.now() - 3600000, 100], // 1 hour ago
    [Date.now() - 1800000, 101], // 30 minutes ago
    [Date.now() - 900000, 102],  // 15 minutes ago
    [Date.now(), 103]            // now
  ];

  // Get initial chart data from delay API
  const { data: delayData, isLoading: delayLoading } = useDelaySparkline(
    assetIdentifier ? [assetIdentifier] : [],
    '15m',
    96
  );

  // Get real-time price updates (15Ï¥àÎßàÎã§ API Ìò∏Ï∂ú)
  const { data: realtimeData } = useRealtimePrices(
    assetIdentifier ? [assetIdentifier] : [],
    'crypto',
    { refetchInterval: 3000 } // 3Ï¥àÎßàÎã§ API Ìò∏Ï∂úÎ°ú ÎπàÎèÑ Í∞êÏÜå
  );

  // Process delay data for initial chart
  useEffect(() => {
    if (delayData && assetIdentifier && delayData[assetIdentifier]) {
      const points = delayData[assetIdentifier];
      
      if (Array.isArray(points) && points.length > 0) {
        // Convert to simple relative timestamps to avoid future date issues
        const now = Date.now();
        
        const formattedData = points
          .map((point, index) => {
            // Use relative time from now (1 hour apart for each point to create longer range)
            const timestamp = Math.round(now - (points.length - index - 1) * 60 * 60 * 1000);
            const price = parseFloat(point.price);
            // ÏïàÏ†ÑÌïú Îç∞Ïù¥ÌÑ∞ Ìè¨Îß∑ÌåÖ (ÏÜåÏàòÏ†ê ÏûêÎ¶øÏàò Ï†úÌïú)
            const safePrice = isNaN(price) ? null : parseFloat(price.toFixed(4));
            return safePrice === null ? null : [timestamp, safePrice];
          })
          .filter(point => point !== null);
        
        if (formattedData.length > 0) {
          // YÏ∂ï Î≤îÏúÑ Í≥ÑÏÇ∞ Î∞è Í≥†Ï†ï
          const prices = formattedData.map(point => point[1]);
          const minPrice = Math.min(...prices);
          const maxPrice = Math.max(...prices);
          const priceRange = maxPrice - minPrice;
          const padding = priceRange * 0.1; // 10% Ìå®Îî©
          
          setYAxisRange({
            min: parseFloat((minPrice - padding).toFixed(4)),
            max: parseFloat((maxPrice + padding).toFixed(4))
          });
          
          // XÏ∂ï Î≤îÏúÑ Í≥ÑÏÇ∞ Î∞è Í≥†Ï†ï (Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤¥ Î≤îÏúÑ)
          const timestamps = formattedData.map(point => point[0]);
          const minTime = Math.min(...timestamps);
          const maxTime = Math.max(...timestamps);
          
          // Î™®Îì† ÌôîÎ©¥ÏóêÏÑú ÎèôÏùºÌïú Ìå®Îî© Ï†ÅÏö©
          const rightPaddingMs = 4 * 60 * 60 * 1000; // +4h
          const leftPaddingMs = 2 * 60 * 60 * 1000; // +2h
          
          setXAxisRange({
            min: Math.round(minTime - leftPaddingMs),
            max: Math.round(maxTime + rightPaddingMs)
          });
          
          // ÎÑ§ÎπÑÍ≤åÏù¥ÌÑ∞ Ï¥àÍ∏∞ ÏÑ†ÌÉù Î≤îÏúÑ Í≥ÑÏÇ∞ (Ï†ÑÏ≤¥ Í∏∞Í∞ÑÏùò 80%)
          const effectiveMaxForCalc = maxTime + rightPaddingMs;
          const effectiveMinForCalc = minTime - leftPaddingMs;
          const totalTimeRange = effectiveMaxForCalc - effectiveMinForCalc;
          const navigatorRange = totalTimeRange * 0.8; // Ï†ÑÏ≤¥ Í∏∞Í∞ÑÏùò 80%
          const navigatorMin = effectiveMaxForCalc - navigatorRange; // ÏµúÏã†+Ìå®Îî©ÏóêÏÑú 80% Î≤îÏúÑÎßåÌÅº Ï†Ñ
          const navigatorMax = effectiveMaxForCalc; // ÏµúÏã† ÏãúÍ∞Ñ + Ìå®Îî©
          
          // ÏΩòÏÜîÏóê Ï¥àÍ∏∞ Ï∂ï Î≤îÏúÑ Î∞è ÎÑ§ÎπÑÍ≤åÏù¥ÌÑ∞ Î≤îÏúÑ Ï∂úÎ†•
          console.log('üìä Ï¥àÍ∏∞ Ï∂ï Î≤îÏúÑ ÏÑ§Ï†ï:', {
            'ÌôîÎ©¥ ÌÉÄÏûÖ': 'ÌÜµÏùºÎêú ÏÑ§Ï†ï',
            'XÏ∂ï (ÏãúÍ∞Ñ)': {
              min: new Date(minTime).toLocaleString(),
              max: new Date(maxTime).toLocaleString(),
              range: `${((maxTime - minTime) / (1000 * 60 * 60)).toFixed(1)}ÏãúÍ∞Ñ`
            },
            'XÏ∂ï Ìå®Îî©': {
              left: `${(leftPaddingMs / (1000 * 60 * 60)).toFixed(1)}ÏãúÍ∞Ñ`,
              right: `${(rightPaddingMs / (1000 * 60 * 60)).toFixed(1)}ÏãúÍ∞Ñ`,
              total: `${((leftPaddingMs + rightPaddingMs) / (1000 * 60 * 60)).toFixed(1)}ÏãúÍ∞Ñ`
            },
            'YÏ∂ï (Í∞ÄÍ≤©)': {
              min: minPrice.toFixed(2),
              max: maxPrice.toFixed(2),
              range: `${(maxPrice - minPrice).toFixed(2)}`,
              padding: `${padding.toFixed(2)} (10%)`
            },
            'ÎÑ§ÎπÑÍ≤åÏù¥ÌÑ∞ Ï¥àÍ∏∞ ÏÑ†ÌÉù (80%)': {
              min: new Date(navigatorMin).toLocaleString(),
              max: new Date(navigatorMax).toLocaleString(),
              range: `${((navigatorMax - navigatorMin) / (1000 * 60 * 60)).toFixed(1)}ÏãúÍ∞Ñ`,
              'Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ ÎåÄÎπÑ': `${(((navigatorMax - navigatorMin) / (maxTime - minTime)) * 100).toFixed(1)}%`
            }
          });
          
          setChartData(formattedData);
          setIsInitialized(true);
        }
      }
    }
  }, [delayData, assetIdentifier]);

  // Update chart with real-time data (like original temp_debug.js)
  useEffect(() => {
    if (realtimeData && assetIdentifier && realtimeData[assetIdentifier] && isInitialized) {
      const latestPrice = realtimeData[assetIdentifier];
      if (latestPrice && latestPrice.price) {
        const newPrice = parseFloat(latestPrice.price);
        
        // Only update if price is valid
        if (!isNaN(newPrice)) {
          // Set initial price if not set
          if (!initialPrice) {
            setInitialPrice(newPrice);
          }
          
          // Update base price for random variation
          setBasePrice(newPrice);
          
          // ÏΩòÏÜî Î°úÍ∑∏Îäî ÏÉà Ìè¨Ïù∏Ìä∏ Ï∂îÍ∞ÄÏãúÏóêÎßå Ï∂úÎ†• (ÏïÑÎûòÏóêÏÑú Ï≤òÎ¶¨)
          
          // 15Ï¥àÎßàÎã§ ÏÉà Ìè¨Ïù∏Ìä∏ Ï∂îÍ∞Ä (ÎûúÎç§ Î≥ÄÌôîÎäî Î≥ÑÎèÑ useEffectÏóêÏÑú Ï≤òÎ¶¨)
          setChartData(prevData => {
            if (prevData.length === 0) return [[Date.now(), newPrice]];
            
            const newData = [...prevData];
            const lastPoint = newData[newData.length - 1];
            const currentTime = Date.now();
            
            // Add new point every 15 seconds
            if (currentTime - lastPoint[0] >= 15000) {
              // ÏïàÏ†ÑÌïú Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ Ï∂îÍ∞Ä (ÏÜåÏàòÏ†ê ÏûêÎ¶øÏàò Ï†úÌïú)
              const safePrice = parseFloat(newPrice.toFixed(4));
              const safeTime = Math.round(currentTime);
              // Î∞©Ìñ• Í≥ÑÏÇ∞ (Ïù¥Ï†Ñ Ìè¨Ïù∏Ìä∏ ÎåÄÎπÑ)
              if (lastPoint && typeof lastPoint[1] === 'number') {
                if (safePrice > lastPoint[1]) setLastPointDirection('up');
                else if (safePrice < lastPoint[1]) setLastPointDirection('down');
                else setLastPointDirection('flat');
              }
              newData.push([safeTime, safePrice]);
              
              // Keep only last 200 points
              if (newData.length > 200) {
                newData.shift(); // Remove first point
              }
              
              // ÏΩòÏÜî Î°úÍ∑∏Îäî ÏÉà Ìè¨Ïù∏Ìä∏Í∞Ä Ï∂îÍ∞ÄÎê† ÎïåÎßå Ï∂úÎ†•
              if (delayData && delayData[assetIdentifier] && delayData[assetIdentifier].length > 0) {
                const lastDelayPoint = delayData[assetIdentifier][delayData[assetIdentifier].length - 1];
                const delayPrice = parseFloat(lastDelayPoint.price);
                const priceDiff = newPrice - delayPrice;
                const priceDiffPercent = ((priceDiff / delayPrice) * 100).toFixed(2);
                
                // Calculate time difference
                const delayTime = new Date(lastDelayPoint.timestamp_utc || lastDelayPoint.timestamp);
                const realtimeTime = new Date();
                const timeDiffMs = realtimeTime - delayTime;
                const timeDiffMinutes = Math.round(timeDiffMs / (1000 * 60));
                
                console.log('üìä ÏÉà Ìè¨Ïù∏Ìä∏ Ï∂îÍ∞Ä - Îç∞Ïù¥ÌÑ∞ ÎπÑÍµê:', {
                  'quotes-delay-price (ÎßàÏßÄÎßâ)': {
                    timestamp: lastDelayPoint.timestamp_utc || lastDelayPoint.timestamp,
                    price: delayPrice,
                    'ÏãúÍ∞ÑÏ∞®(Î∂Ñ)': timeDiffMinutes
                  },
                  'quotes-price (Ïã§ÏãúÍ∞Ñ)': {
                    timestamp: realtimeTime.toISOString(),
                    price: newPrice
                  },
                  'Í∏∞Ï§ÄÍ∞ÄÍ≤© (basePrice)': {
                    price: newPrice
                  },
                  'Ï∞®Ïù¥': {
                    Ï†àÎåÄÍ∞í: priceDiff.toFixed(4),
                    ÎπÑÏú®: `${priceDiffPercent}%`
                  }
                });
              }
            }
            
            return newData;
          });
        }
      }
    }
  }, [realtimeData, assetIdentifier, isInitialized, delayData]);

  // 1500msÎßàÎã§ ÎûúÎç§ Î≥ÄÌôî Ï†ÅÏö© (ÎπàÎèÑ Í∞êÏÜå)
  useEffect(() => {
    if (!basePrice || !isInitialized || !initialPrice) return;

    const interval = setInterval(() => {
      setChartData(prevData => {
        if (prevData.length === 0) return prevData;
        
        const newData = [...prevData];
        const lastPoint = newData[newData.length - 1];
        
        // Add random variation (0.01~0.05% range)
        const randomVariation = (Math.random() * 0.0004) + 0.0001; // 0.01~0.05% range
        const isPositive = Math.random() > 0.5; // 50% ÌôïÎ•†Î°ú ÏñëÏàò/ÏùåÏàò
        const finalVariation = isPositive ? randomVariation : -randomVariation;
        const variedPrice = parseFloat((basePrice * (1 + finalVariation)).toFixed(4));
        
        // ÏïàÏ†ÑÌïú Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (ÏÜåÏàòÏ†ê ÏûêÎ¶øÏàò Ï†úÌïú)
        const safePrice = parseFloat(variedPrice.toFixed(4));
        const safeTime = Math.round(lastPoint[0]); // ÏãúÍ∞ÑÏùÄ Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå
        // Î∞©Ìñ• Í≥ÑÏÇ∞ (Ïù¥Ï†Ñ Ìè¨Ïù∏Ìä∏ ÎåÄÎπÑ)
        if (lastPoint && typeof lastPoint[1] === 'number') {
          if (safePrice > lastPoint[1]) setLastPointDirection('up');
          else if (safePrice < lastPoint[1]) setLastPointDirection('down');
          else setLastPointDirection('flat');
        }
        newData[newData.length - 1] = [safeTime, safePrice];
        
        return newData;
      });
    }, 1500); // 1.5Ï¥àÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏

    return () => clearInterval(interval);
  }, [basePrice, isInitialized, initialPrice]);

  // ÌôîÎ©¥ ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Í∞êÏßÄ Ï†úÍ±∞ - Î™®Îì† ÌôîÎ©¥ÏóêÏÑú ÎèôÏùºÌïú ÏÑ§Ï†ï ÏÇ¨Ïö©

  // Ìã∞Ïª§Î•º Í∏∞Î∞òÏúºÎ°ú Ï∞®Ìä∏ ÌÉÄÏù¥ÌãÄ ÏÉùÏÑ±
  const getChartTitle = (ticker) => {
    if (!ticker) return 'Real-time Price Chart'
    
    // Ìã∞Ïª§Î≥Ñ ÌëúÏãúÎ™Ö Îß§Ìïë (ÌöåÏÇ¨Î™Ö(Ìã∞Ïª§) ÌòïÏãù)
    const tickerMap = {
      'BTCUSDT': 'Bitcoin (BTCUSDT)',
      'ETHUSDT': 'Ethereum (ETHUSDT)',
      'XRPUSDT': 'Ripple (XRPUSDT)',
      'ADAUSDT': 'Cardano (ADAUSDT)',
      'AVGO': 'Broadcom Inc. (AVGO)',
      'TSLA': 'Tesla Inc. (TSLA)',
      'GCUSD': 'Gold Spot (GCUSD)',
      'AAPL': 'Apple Inc. (AAPL)',
      'MSFT': 'Microsoft Corporation (MSFT)',
      'AMZN': 'Amazon.com, Inc. (AMZN)',
      'NVDA': 'NVIDIA Corporation (NVDA)',
      'GOOG': 'Alphabet Inc. (GOOG)',
      'META': 'Meta Platforms Inc. (META)',
      'SPY': 'SPDR S&P 500 ETF Trust (SPY)',
      'QQQ': 'Invesco QQQ Trust (QQQ)'
    }
    
    return tickerMap[ticker] || `${ticker} Price Chart`
  }

  // Chart options with real data
const options = {
    title: {
        text: getChartTitle(assetIdentifier),
        style: { color: '#ffffff' }
    },

    chart: {
        backgroundColor: '#1a1a1a',
        style: { fontFamily: 'Inter, sans-serif' },
        animation: false, // Ïï†ÎãàÎ©îÏù¥ÏÖò ÎπÑÌôúÏÑ±ÌôîÎ°ú SVG ÏóêÎü¨ Î∞©ÏßÄ
        height: 300, // Î™®Îì† ÌôîÎ©¥ÏóêÏÑú 300px
        events: {
            load() {
                const chart = this;
                if (chart.renderer && chart.renderer.globalAnimation) {
                    chart.renderer.globalAnimation = false;
                }
            },
            error(e) {
                console.warn('Chart rendering error:', e);
                if (this && this.redraw) {
                    setTimeout(() => {
                        try {
                            this.redraw();
                        } catch (err) {
                            console.error('Chart redraw failed:', err);
                        }
                    }, 100);
                }
            }
        }
    },

    xAxis: {
        type: 'datetime',
        overscroll: 14400000, // Î™®Îì† ÌôîÎ©¥ÏóêÏÑú 4h
        gridLineWidth: 1,
        gridLineColor: '#333333',
        min: xAxisRange.min,
        max: xAxisRange.max,
        ordinal: false,
        breaks: [],
        labels: { style: { color: '#a0a0a0' } },
        dateTimeLabelFormats: {
            millisecond: '%H:%M:%S.%L',
            second: '%H:%M:%S',
            minute: '%H:%M',
            hour: '%H:%M',
            day: '%m/%d',
            week: '%m/%d',
            month: '%m/%Y',
            year: '%Y'
        },
        // SVG ÏóêÎü¨ Î∞©ÏßÄÎ•º ÏúÑÌïú Ï∂îÍ∞Ä ÏÑ§Ï†ï
        minPadding: 0,
        maxPadding: 0
    },

    yAxis: {
        // YÏ∂ï Î≤îÏúÑ Í≥†Ï†ï (Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Í∏∞Ï§Ä)
        min: yAxisRange.min,
        max: yAxisRange.max,
        minPadding: 0,
        maxPadding: 0,
        startOnTick: false,
        endOnTick: false,
        gridLineColor: '#333333',
        labels: {
            style: { color: '#a0a0a0' },
            formatter: function () { return typeof this.value === 'number' ? this.value.toFixed(2) : this.value; }
        },
        lastVisiblePrice: {
            enabled: true,
            label: {
                enabled: true,
                style: { color: '#000000', fontWeight: 'bold' },
                backgroundColor: '#00d4ff',
                borderColor: '#ffffff',
                borderWidth: 1,
                borderRadius: 2,
                padding: 2
            }
        }
    },

    rangeSelector: {
        enabled: false, // Î™®Îì† ÌôîÎ©¥ÏóêÏÑú ÎπÑÌôúÏÑ±Ìôî
        buttons: [{
            type: 'minute',
            count: 15,
            text: '15m'
        }, {
            type: 'minute',
            count: 1000,
            text: '1h'
        },
        {
            type: 'hour',
            count: 48, // 48ÏãúÍ∞Ñ (ÏïΩ 2Ïùº) - Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Ïùò 80%Ïóê Ìï¥Îãπ
            text: '4h'
        },
        {
            type: 'all',
            count: 1,
            text: 'All'
        }],
        selected: 2,
        inputEnabled: false,
        events: {
            select(e) {
                const chart = this;
                const buttonIndex = e.buttonIndex;
                
                // "4h" Î≤ÑÌäº (index 2) ÌÅ¥Î¶≠ Ïãú 80% Î≤îÏúÑ ÏÑ§Ï†ï (+4h padding Ìè¨Ìï®)
                if (buttonIndex === 2) {
                    setTimeout(() => {
                        if (chart.xAxis && chart.xAxis[0]) {
                            const xAxis = chart.xAxis[0];
                            const dataMin = xAxis.dataMin;
                            const dataMax = xAxis.dataMax;
                            const rightPaddingMs = 4 * 60 * 60 * 1000; // +4h padding
                            
                            if (dataMin && dataMax) {
                                const effectiveMax = dataMax + rightPaddingMs;
                                const totalRange = effectiveMax - dataMin;
                                const navigatorRange = totalRange * 0.8; // 80% Î≤îÏúÑ
                                const navigatorMin = effectiveMax - navigatorRange;
                                const navigatorMax = effectiveMax;
                                
                                console.log('üéØ 4h Î≤ÑÌäº ÌÅ¥Î¶≠ - 80% Î≤îÏúÑ ÏÑ§Ï†ï:', {
                                    'ÏÑ§Ï†ïÌï† Î≤îÏúÑ': {
                                        min: new Date(navigatorMin).toLocaleString(),
                                        max: new Date(navigatorMax).toLocaleString(),
                                        range: `${((navigatorMax - navigatorMin) / (1000 * 60 * 60)).toFixed(1)}ÏãúÍ∞Ñ`
                                    }
                                });
                                
                                xAxis.setExtremes(navigatorMin, navigatorMax);
                            }
                        }
                    }, 50);
                }
            }
        }
    },

    navigator: {
        enabled: false, // Î™®Îì† ÌôîÎ©¥ÏóêÏÑú ÎπÑÌôúÏÑ±Ìôî
        series: {
            // Extend navigator data to include right padding so the selection bar can extend visually
            data: (chartData && chartData.length > 0)
              ? [...chartData, [xAxisRange.max, chartData[chartData.length - 1][1]]]
              : [],
            color: '#66bfff' // brighter color for visibility
        },
        xAxis: {
            dateTimeLabelFormats: {
                millisecond: '%H:%M:%S.%L',
                second: '%H:%M:%S',
                minute: '%H:%M',
                hour: '%H:%M',
                day: '%m/%d',
                week: '%m/%d',
                month: '%m/%d',
                year: '%Y'
            }
        },
        yAxis: {
            // ÎÑ§ÎπÑÍ≤åÏù¥ÌÑ∞ YÏ∂ï Î≤îÏúÑ Í≥†Ï†ï (Î©îÏù∏ Ï∞®Ìä∏ÏôÄ ÎèôÏùº)
            min: yAxisRange.min,
            max: yAxisRange.max,
            minPadding: 0,
            maxPadding: 0,
            startOnTick: false,
            endOnTick: false
        },
        // ÎÑ§ÎπÑÍ≤åÏù¥ÌÑ∞ Ï¥àÍ∏∞ ÏÑ†ÌÉù Î≤îÏúÑ ÏÑ§Ï†ï (Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Ïùò 80%)
        height: 40,
        margin: 2
    },

    tooltip: {
        enabled: false
    },

    exporting: {
        enabled: false // Î™®Îì† ÌôîÎ©¥ÏóêÏÑú ÎπÑÌôúÏÑ±Ìôî
    },

    series: [
        {
            type: 'spline',
            name: 'Price',
            color: '#00d4ff',
            data: chartData.length > 0 ? chartData : fallbackData,
            animation: false,
            lineWidth: 2
        },
        {
            id: 'last-point',
            type: 'spline',
            name: 'Last Price',
            data: chartData.length > 0 ? [chartData[chartData.length - 1]] : [],
            color: 'transparent',
            lineWidth: 0,
            className: 'highcharts-last-point-marker',
            marker: {
                enabled: true,
                symbol: 'circle',
                radius: 5,
                fillColor: lastPointDirection === 'down' ? '#ff4d4f' : '#00d4ff',
                lineColor: '#ffffff',
                lineWidth: 2
            },
            dataLabels: {
                enabled: true,
                formatter: function () { return typeof this.y === 'number' ? this.y.toFixed(2) : this.y; },
                backgroundColor: 'transparent',
                borderColor: 'transparent',
                borderWidth: 0,
                borderRadius: 0,
                padding: 5,
                y: -30,
                style: { color: (lastPointDirection === 'down' ? '#ff4d4f' : '#00d4ff'), fontWeight: 'bold' }
            }
        }
    ]
};

  // Show loading state only if we have no data at all
  if (delayLoading && chartData.length === 0) {
    return (
      <div style={{ 
        display: 'flex', 
        justifyContent: 'center', 
        alignItems: 'center', 
        height: '300px',
        minHeight: '300px',
        width: '100%',
        backgroundColor: '#1a1a1a',
        color: '#ffffff'
      }}>
        <div>Loading chart data...</div>
      </div>
    );
  }

  return (
    <div ref={containerRef} style={{ width: '100%', height: '300px', minHeight: '300px' }}>
      <style>
        {glowingMarkerStyle}
        {`
          .highcharts-range-selector-group,
          .highcharts-exporting-group {
            display: none !important;
          }
          .highcharts-range-selector-buttons,
          .highcharts-exporting-group {
            display: none !important;
          }
        `}
        {`
          .highcharts-navigator,
          .highcharts-scrollbar {
            display: none !important;
          }
          .highcharts-navigator-container,
          .highcharts-scrollbar-container {
            display: none !important;
          }
        `}
        {`
          .highcharts-container {
            height: 300px !important;
            max-height: 300px !important;
          }
        `}
      </style>
      <HighchartsReact
        highcharts={Highcharts}
        constructorType={'stockChart'}
        options={options}
        ref={chartRef}
        containerProps={{ style: { height: '300px' } }}
        callback={(chart) => {
          // Add error handling for chart
          if (chart && typeof chart.on === 'function') {
            chart.on('error', (e) => {
              console.warn('Chart error:', e);
            });
          }
          
          // Î™®Îì† ÌôîÎ©¥ÏóêÏÑú Range selectorÏôÄ Exporting Î≤ÑÌäº Ïà®Í∏∞Í∏∞
          setTimeout(() => {
            const chartContainer = chart.container;
            if (chartContainer) {
              // Range selector Ïà®Í∏∞Í∏∞
              const rangeSelectors = chartContainer.querySelectorAll('.highcharts-range-selector-group, .highcharts-range-selector-buttons');
              rangeSelectors.forEach(el => {
                if (el) el.style.display = 'none';
              });
              
              // Exporting Î≤ÑÌäº Ïà®Í∏∞Í∏∞
              const exportingGroups = chartContainer.querySelectorAll('.highcharts-exporting-group');
              exportingGroups.forEach(el => {
                if (el) el.style.display = 'none';
              });
            }
          }, 100);
          
          // Î™®Îì† ÌôîÎ©¥ÏóêÏÑú NavigatorÏôÄ Scrollbar Ïà®Í∏∞Í∏∞
          setTimeout(() => {
            const chartContainer = chart.container;
            if (chartContainer) {
              // Navigator Ïà®Í∏∞Í∏∞
              const navigators = chartContainer.querySelectorAll('.highcharts-navigator, .highcharts-navigator-container');
              navigators.forEach(el => {
                if (el) el.style.display = 'none';
              });
              
              // Scrollbar Ïà®Í∏∞Í∏∞
              const scrollbars = chartContainer.querySelectorAll('.highcharts-scrollbar, .highcharts-scrollbar-container');
              scrollbars.forEach(el => {
                if (el) el.style.display = 'none';
              });
            }
          }, 100);
        }}
      />
    </div>
  );
};

const MiniPriceChart = ({ assetIdentifier, symbols }) => {
  if (Array.isArray(symbols) && symbols.length > 0) {
    return (
      <div style={{ width: '100%', padding: '4px' }}>
        <div
          style={{
            display: 'grid',
            gridTemplateColumns: 'repeat(2, minmax(0, 1fr))',
            gap: '4px'
          }}
        >
          {symbols.map((sym) => (
            <div key={sym} style={{ padding: '2px' }}>
              <MiniPriceChartItem assetIdentifier={sym} />
            </div>
          ))}
        </div>
      </div>
    );
  }
  return <MiniPriceChartItem assetIdentifier={assetIdentifier} />;
};

export default MiniPriceChart;